var m=class extends Error{constructor(e){super(e),this.name="UpstashError"}};var A=class{baseUrl;headers;options;retry;constructor(e){this.options={cache:e.cache,signal:e.signal},this.baseUrl=e.baseUrl.replace(/\/$/,""),this.headers={"Content-Type":"application/json",...e.headers},this.retry=typeof e?.retry=="boolean"&&e?.retry===!1?{attempts:1,backoff:()=>0}:{attempts:e?.retry?.retries??5,backoff:e?.retry?.backoff??(t=>Math.exp(t)*50)}}async request(e){let t={cache:this.options.cache,method:"POST",headers:this.headers,body:JSON.stringify(e.body),keepalive:!0,signal:this.options.signal},a=null,s=null;for(let f=0;f<=this.retry.attempts;f++)try{a=await fetch([this.baseUrl,...e.path??[]].join("/"),t);break}catch(D){if(this.options.signal?.aborted){let P=new Blob([JSON.stringify({result:this.options.signal.reason??"Aborted"})]),q={status:200,statusText:this.options.signal.reason??"Aborted"};a=new Response(P,q);break}s=D,await new Promise(P=>setTimeout(P,this.retry.backoff(f)))}if(!a)throw s??new Error("Exhausted all retries");let o=await a.json();if(!a.ok)throw new m(`${o.error}`);return{result:o.result,error:o.error}}};var r=class{payload;endpoint;constructor(e,t){this.payload=e,this.endpoint=t}async exec(e){let{result:t,error:a}=await e.request({body:this.payload,path:[this.endpoint]});if(a)throw new m(a);if(t===void 0)throw new TypeError("Request did not return a result");return t}};var i=class extends r{constructor(e,t){let a="delete";t?.namespace&&(a=`${a}/${t.namespace}`);let s=[];Array.isArray(e)?s.push(...e):s.push(e),super(s,a)}};var x=class extends r{constructor(e,t){let a="query";a=e.some(o=>o.data)?"query-data":"query",t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}};var p=class extends r{constructor(e,t){let a="query";"data"in e&&(a="query-data"),t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}};var d=class extends r{constructor(e,t){let a="upsert";Array.isArray(e)?a=e.some(o=>w(o))?"upsert":"upsert-data":a=w(e)?"upsert":"upsert-data",t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}},w=n=>"vector"in n;var c=class extends r{constructor([e,t]){let a="fetch";t?.namespace&&(a=`${a}/${t.namespace}`,delete t.namespace),super({ids:e,...t},a)}};var u=class extends r{constructor(e,t){let a="range";t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}};var l=class extends r{constructor(e){let t="reset";e?.namespace?t=`${t}/${e.namespace}`:e?.all&&(t=`${t}?all`),super([],t)}};var h=class extends r{constructor(){super([],"info")}};var C=class{client;namespace;constructor(e,t){this.client=e,this.namespace=t}upsert=e=>new d(e,{namespace:this.namespace}).exec(this.client);update=e=>new y(e,{namespace:this.namespace}).exec(this.client);fetch=(...e)=>(e[1]?e[1].namespace=this.namespace:e[1]={namespace:this.namespace},new c(e).exec(this.client));query=e=>new p(e,{namespace:this.namespace}).exec(this.client);delete=e=>new i(e,{namespace:this.namespace}).exec(this.client);range=e=>new u(e,{namespace:this.namespace}).exec(this.client);reset=()=>new l({namespace:this.namespace}).exec(this.client)};var y=class extends r{constructor(e,t){let a="update";t?.namespace&&(a=`${a}/${t.namespace}`),super(e,a)}};var T=class extends r{constructor(e){super(e,"resumable-query-next")}};var M=class extends r{constructor(e,t){let a="resumable-query";"data"in e&&(a="resumable-query-data"),t&&(a=`${a}/${t}`),super(e,a)}};var b=class extends r{constructor(e){super(e,"resumable-query-end")}};var R=class{uuid;start;fetchNext;stop;constructor(e,t,a){this.start=async()=>{let s=await new M(e,a).exec(t);return this.uuid=s.uuid,s},this.fetchNext=s=>{if(!this.uuid)throw new Error("The resumable query has already been stopped. Please start another resumable query.");return new T({uuid:this.uuid,additionalK:s}).exec(t)},this.stop=async()=>{if(!this.uuid)throw new Error("Resumable query has not been started. Call start() first.");let s=await new b({uuid:this.uuid}).exec(t);return this.uuid="",s}}};var g=class extends r{constructor(){super([],"list-namespaces")}};var E=class extends r{constructor(e){let t=`delete-namespace/${e}`;super([],t)}};var Q=class{client;constructor(e){this.client=e}namespace=e=>new C(this.client,e);delete=(e,t)=>new i(e,t).exec(this.client);query=(e,t)=>new p(e,t).exec(this.client);queryMany=(e,t)=>new x(e,t).exec(this.client);resumableQuery=async(e,t)=>{let a=new R(e,this.client,t?.namespace),s=await a.start(),{fetchNext:o,stop:f}=a;return{fetchNext:o,stop:f,result:s.scores}};upsert=(e,t)=>new d(e,t).exec(this.client);update=(e,t)=>new y(e,t).exec(this.client);fetch=(...e)=>new c(e).exec(this.client);reset=e=>new l(e).exec(this.client);range=(e,t)=>new u(e,t).exec(this.client);info=()=>new h().exec(this.client);listNamespaces=()=>new g().exec(this.client);deleteNamespace=e=>new E(e).exec(this.client)};export{A as a,Q as b};
